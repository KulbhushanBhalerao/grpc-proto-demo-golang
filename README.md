# gRPC Protobuf Demo - Golang

A simple, beginner-friendly gRPC application in Go with Protocol Buffers. This project demonstrates both unary RPC and server-side streaming RPC patterns.

## üìö What You'll Learn

- How to define services using Protocol Buffers (`.proto` files)
- How to generate Go code from `.proto` files
- How to implement a gRPC server
- How to create a gRPC client
- How to use unary RPCs (single request/response)
- How to use server-side streaming RPCs (single request, multiple responses)

## üèóÔ∏è Project Structure

```
grpc-proto-demo-golang/
‚îú‚îÄ‚îÄ proto/
‚îÇ   ‚îú‚îÄ‚îÄ greeting.proto          # Protobuf service definition (you write this)
‚îÇ   ‚îú‚îÄ‚îÄ greeting.pb.go          # Generated: Protocol Buffer messages
‚îÇ   ‚îî‚îÄ‚îÄ greeting_grpc.pb.go     # Generated: gRPC service code
‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îî‚îÄ‚îÄ main.go                 # gRPC server implementation (you write this)
‚îú‚îÄ‚îÄ client/
‚îÇ   ‚îî‚îÄ‚îÄ main.go                 # gRPC client implementation (you write this)
‚îú‚îÄ‚îÄ go.mod                      # Go module dependencies
‚îú‚îÄ‚îÄ go.sum                      # Dependency checksums
‚îú‚îÄ‚îÄ .gitignore                  # Git ignore rules
‚îî‚îÄ‚îÄ README.md                   # This file
```

## üìÇ Detailed File Descriptions

### Files You Write

#### `proto/greeting.proto`
**Purpose**: Define your service contract using Protocol Buffer syntax.

This is the source of truth for your API. It contains:
- **Message definitions**: Data structures like `HelloRequest` and `HelloResponse`
- **Service definitions**: RPC methods like `SayHello` and `SayHelloMultiple`
- **Field types and numbers**: Each field has a type (string, int32, etc.) and a unique number

**Why it matters**: This single file defines the contract between client and server. Both sides generate code from this file, ensuring they always speak the same "language."

#### `server/main.go`
**Purpose**: Implement the gRPC server that handles client requests.

Contains:
- **Service implementation**: Actual business logic for each RPC method
- **Server setup**: Network listener and gRPC server initialization
- **Request handlers**: Code that processes incoming requests and returns responses

**Key concepts**:
- Implements the interface defined in `greeting_grpc.pb.go`
- Must implement all methods from the service definition
- Handles both unary (single) and streaming (multiple) responses

#### `client/main.go`
**Purpose**: Create a gRPC client that calls the server.

Contains:
- **Connection setup**: Establishes connection to the server
- **Client creation**: Creates a typed client from generated code
- **RPC calls**: Invokes remote methods like calling local functions
- **Response handling**: Processes both single and streaming responses

**Key concepts**:
- Uses the client stub from `greeting_grpc.pb.go`
- Abstracts away all network communication
- Provides type-safe method calls

### Generated Files (Don't Edit These!)

#### `proto/greeting.pb.go`
**Purpose**: Contains Go structs for Protocol Buffer messages.

**Auto-generated by**: `protoc` with `--go_out` flag

**What it contains**:
- **Message structs**: Go types for `HelloRequest` and `HelloResponse`
- **Getter methods**: Safe accessors like `GetName()` and `GetMessage()`
- **Marshal/Unmarshal code**: Efficient binary serialization
- **Metadata**: Field descriptors and reflection information

**Example from this file**:
```go
type HelloRequest struct {
    Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *HelloRequest) GetName() string {
    if x != nil {
        return x.Name
    }
    return ""
}
```

**Why you don't edit it**: Any changes would be overwritten when you regenerate from `.proto` file. Always modify `greeting.proto` instead.

#### `proto/greeting_grpc.pb.go`
**Purpose**: Contains gRPC service interfaces and client/server code.

**Auto-generated by**: `protoc` with `--go-grpc_out` flag

**What it contains**:
- **Service interface**: Go interface that server must implement
- **Client stub**: Type-safe client for calling remote methods
- **Server registration**: Code to register your implementation with gRPC
- **Network handling**: All the low-level gRPC communication logic

**Example from this file**:
```go
// Interface your server must implement
type GreetingServiceServer interface {
    SayHello(context.Context, *HelloRequest) (*HelloResponse, error)
    SayHelloMultiple(*HelloRequest, GreetingService_SayHelloMultipleServer) error
}

// Client stub for making RPC calls
type GreetingServiceClient interface {
    SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloResponse, error)
    SayHelloMultiple(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (GreetingService_SayHelloMultipleClient, error)
}
```

**Why you don't edit it**: This is the glue between your code and the gRPC framework. Regenerate it whenever you change the service definition.

### Configuration Files

#### `go.mod`
**Purpose**: Defines the Go module and its dependencies.

**Created by**: `go mod init` command

**What it contains**:
- Module name: `github.com/KulbhushanBhalerao/grpc-proto-demo-golang`
- Go version requirement
- Direct dependencies: `google.golang.org/grpc`, `google.golang.org/protobuf`
- Indirect dependencies: Listed automatically by `go mod tidy`

#### `go.sum`
**Purpose**: Cryptographic checksums for all dependencies.

**Created by**: `go mod tidy` and other `go` commands

**Why it exists**: Ensures dependency integrity. Go verifies that downloaded dependencies match these checksums, protecting against tampering.

## üîÑ The Code Generation Workflow

```
1. Write greeting.proto
   (Define your service)
        ‚Üì
2. Run protoc command
   (Generate Go code)
        ‚Üì
3. greeting.pb.go + greeting_grpc.pb.go created
   (Message types + gRPC interfaces)
        ‚Üì
4. Write server/main.go
   (Implement the service interface)
        ‚Üì
5. Write client/main.go
   (Use the client stub)
        ‚Üì
6. Run server and client
   (Communication happens!)
```

## üöÄ Prerequisites

Before running this project, make sure you have:

1. **Go** (1.20 or later)
   ```bash
   go version
   ```

2. **Protocol Buffer Compiler** (protoc)
   ```bash
   # macOS
   brew install protobuf
   
   # Verify installation
   protoc --version
   ```

3. **Go Protobuf Plugins**
   ```bash
   go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
   go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
   ```

## üì¶ Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/KulbhushanBhalerao/grpc-proto-demo-golang.git
   cd grpc-proto-demo-golang
   ```

2. Install dependencies:
   ```bash
   go mod tidy
   ```

## ‚ñ∂Ô∏è Running the Application

### Step 1: Start the Server

Open a terminal and run:

```bash
go run server/main.go
```

You should see:
```
‚úÖ gRPC Server is running on port 50051...
Waiting for client connections...
```

### Step 2: Run the Client

Open a **new terminal** (keep the server running) and run:

```bash
go run client/main.go
```

You'll see the client making two types of RPC calls:
1. **Simple unary call** - Single request, single response
2. **Server streaming call** - Single request, multiple responses

## üîç Understanding the Code

### 1. Protocol Buffer Definition (`proto/greeting.proto`)

This file defines our service contract:
- **Service**: `GreetingService` with two RPC methods
- **Messages**: `HelloRequest` and `HelloResponse`

```protobuf
service GreetingService {
  rpc SayHello (HelloRequest) returns (HelloResponse) {}
  rpc SayHelloMultiple (HelloRequest) returns (stream HelloResponse) {}
}
```

### 2. Server Implementation (`server/main.go`)

The server:
- Implements the `GreetingService` interface
- Listens on port 50051
- Handles both unary and streaming RPCs
- Logs all incoming requests

**Key points:**
- `SayHello` - Returns a single greeting message
- `SayHelloMultiple` - Streams 5 greetings with 1-second delays

### 3. Client Implementation (`client/main.go`)

The client:
- Connects to the server on `localhost:50051`
- Makes a simple unary call
- Makes a streaming call and receives multiple responses

## üîÑ Regenerating Protocol Buffer Code

If you modify `proto/greeting.proto`, regenerate the Go code:

```bash
protoc --go_out=. --go_opt=paths=source_relative \
       --go-grpc_out=. --go-grpc_opt=paths=source_relative \
       proto/greeting.proto
```

**What each flag does**:
- `--go_out=.` - Generate `greeting.pb.go` in current directory structure
- `--go_opt=paths=source_relative` - Keep proto file's relative path structure
- `--go-grpc_out=.` - Generate `greeting_grpc.pb.go` in current directory structure
- `--go-grpc_opt=paths=source_relative` - Keep proto file's relative path structure

**When to regenerate**:
- ‚úÖ After adding/removing RPC methods
- ‚úÖ After adding/removing message fields
- ‚úÖ After changing field types or numbers
- ‚úÖ After modifying service definitions

**Important**: Always regenerate both files together. They work as a pair!

## üìù Sample Output

**Server output:**
```
‚úÖ gRPC Server is running on port 50051...
Waiting for client connections...
Received request from: Alice
Received streaming request from: Bob
Sent streaming response #1 to Bob
Sent streaming response #2 to Bob
...
```

**Client output:**
```
üöÄ gRPC Client started...
==================================================

üìû Making simple SayHello call...
‚úÖ Response: Hello, Alice! Welcome to gRPC with Go!
   Count: 1

üì° Making streaming SayHelloMultiple call...
üì® Received: Hello #1, Bob! Streaming response 1 of 5 (Count: 1)
üì® Received: Hello #2, Bob! Streaming response 2 of 5 (Count: 2)
...
‚úÖ Streaming complete!

‚úÖ Client finished successfully!
```

## üéØ Next Steps

Try modifying the code to:
1. **Add a new RPC method** (e.g., `SayGoodbye`)
   - Edit `proto/greeting.proto`
   - Regenerate code with `protoc`
   - Implement in server
   - Call from client

2. **Implement client-side streaming**
   - Client sends multiple requests
   - Server returns single response

3. **Implement bidirectional streaming**
   - Both client and server send multiple messages
   - Real-time communication

4. **Add error handling**
   - Return gRPC status codes
   - Handle connection errors
   - Add retry logic

5. **Add authentication**
   - Use interceptors
   - Add API keys or tokens
   - Implement TLS

6. **Add custom metadata**
   - Send headers with requests
   - Add tracing IDs
   - Pass context information

## ‚ùì Common Questions

**Q: Why do I need two generated files?**
A: `greeting.pb.go` handles message serialization (data structures), while `greeting_grpc.pb.go` handles RPC communication (network calls). Separation of concerns!

**Q: Can I edit the generated files?**
A: No! They'll be overwritten on regeneration. Always modify the `.proto` file and regenerate.

**Q: What if I get "protoc-gen-go: program not found"?**
A: Make sure `$(go env GOPATH)/bin` is in your PATH:
```bash
export PATH="$PATH:$(go env GOPATH)/bin"
```

**Q: How do I add a new field to a message?**
A: Edit the `.proto` file, assign a new unique field number, then regenerate. Never reuse field numbers!

**Q: What's the difference between unary and streaming RPC?**
A:
- **Unary**: Single request ‚Üí Single response (like HTTP)
- **Server streaming**: Single request ‚Üí Multiple responses (like downloading chunks)
- **Client streaming**: Multiple requests ‚Üí Single response (like uploading chunks)
- **Bidirectional**: Multiple requests ‚ü∑ Multiple responses (like chat)

## üìö Learn More

- [gRPC Official Documentation](https://grpc.io/docs/)
- [Protocol Buffers Guide](https://protobuf.dev/)
- [gRPC Go Quick Start](https://grpc.io/docs/languages/go/quickstart/)

## üìÑ License

This project is open source and available under the MIT License.
Simple grpc protobuf demo with golang
